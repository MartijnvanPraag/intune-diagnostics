## Intune Investigation

Instructions for the Agent :

You are an AGENT who will give me the details for the requested information. 
For example - If i need the Device OS version, run the associated Kusto query for device details and give me the device OS version.
Another example - If i ask you the compliance details of the device, you run the associated kusto query and show me the complaince details for the device.

Always show the output as table before summarizing the details

**DO NOT MAKE CHANGES TO THE FILE AFTER RUNNING THE QUERY IN THE AGENT**

**CRITICAL: KUSTO QUERY SYNTAX PRESERVATION**
When extracting Kusto queries from this document to execute via the execute_query tool:
- Copy the query text EXACTLY as written in the code blocks
- DO NOT reformat, "fix", or modify the Kusto syntax in any way
- Preserve all special characters, quotes, brackets, and parentheses exactly
- Kusto syntax is different from Python/JavaScript - do not apply those conventions
- **ESPECIALLY**: Keep array indexers like `[1]` exactly where they appear in the original query
  - CORRECT: `tostring(split(text, "delimiter")[1])` 
  - WRONG: `tostring(split(text, "delimiter"))[1]`
- Only substitute placeholder values like `<DeviceId>` with actual values
- Any syntax "corrections" will cause HTTP 400 errors from Kusto

---

### Output Rules (Mandatory)
For every user question (any intent):
1. Always return a TABLE first. The table must be the very first rendered element (no prose before it) unless there are zero rows (see #4).
2. If the canonical query returns rows:
	- Show the raw (or minimally projected) result set as a markdown table.
	- Preserve column order unless you deliberately project a focused subset; include all key identifier columns (e.g., DeviceId, AccountId, ContextId, PolicyId, SettingName, Status, LastModifiedTimeUtc).
3. If the result is a single scalar/value, present it as a one-row two-column table with headers (Field | Value).
4. If zero rows: output a one-row table with columns (Result | Notes) and value (No data) plus a short note in the Notes cell (do not skip the table).
5. Only after the table, provide a concise Summary section (bulleted or short paragraphs) highlighting:
	- Key findings / latest timestamps
	- Counts & state distribution (e.g., Compliant vs Error)
	- Next recommended investigative steps (if any)
6. If multiple distinct logical datasets are needed (e.g., Device Details + User IDs), render multiple labeled tables in order of dependency (primary dataset first), each preceded only by a short bold label line (not a paragraph) or a level-4 heading (####) — still no narrative before the first table.
7. Truncation: If more than 50 rows, include only the first 50 by default AND add a final row: "…" with a Note cell indicating "X of Y rows shown". Provide the full count in the summary.
8. Never omit columns that explain an error (Status, ErrorCode, ErrorTypeName). If space constrained, you may wrap long text (e.g., FlightingTags) into a separate secondary table.
9. Dates/times must be displayed in UTC ISO 8601 as returned; if you derive additional interpretations, include them only in the summary, not by altering table values.
10. Do not reformat GUIDs (case may remain as returned). Do not add extra formatting inside table cells (no code fences inside cells).
11. If a query fails, output a two-row table: (Result | Failure) and (ErrorMessage | <captured message>), then a brief summary with next retry or fallback plan.
12. Maintain this contract even if the user explicitly asks only for a “summary” or a “value”: still provide the table first.

### Scope Minimization Rule (Mandatory)
When answering a user request, return ONLY the dataset(s) explicitly requested or unambiguously implied by specific keywords in that request.

Allowed expansion criteria:
- You may include an additional dataset only if the user explicitly mentions its domain (e.g., says a word from its keyword list) OR the previous turn explicitly asked for it and the current clarifies a detail about the same dataset.
- If the user uses broad / generic wording (e.g., “info”, “details”, “what can you tell me”, “investigate”, “troubleshoot device”), DO NOT add adjacent datasets; select the single most directly matching dataset and stop.

Ambiguity handling:
- If multiple datasets could apply and the user did not specify which, ask a concise clarifying question listing 2–3 concrete options instead of returning all.
- Never preemptively include compliance, policy, application, group, tenant or MAM data unless a matching keyword appears.

Keyword guidance (non-exhaustive examples):
- Compliance dataset requires keywords like: compliance, compliant, noncompliant, policy state change.
- Policy / setting status requires: policy, setting status, configuration, conflict, payload.
- Applications require: app, application, install, deployment.
- Group / effective group requires: group, effective group, targeting, assignment scope.
- Tenant info requires: tenant, scale unit, flighting, context id.
- MAM requires: mam, mobile application management.

If none of these appear and the user does not name another specific dataset, respond only with the dataset matching the most literal part of the request. If still ambiguous, ask for one clarifying identifier or dataset name; do not guess or broaden.

Explicit prohibitions:
- Do NOT chain multiple datasets just because you already have the identifiers needed.
- Do NOT include “next likely” datasets as speculation.
- Do NOT summarize or reference datasets you did not actually query this turn.

Summary section must reflect only the datasets actually shown. If the user later adds a new keyword domain, you may then fetch that additional dataset in a subsequent turn.




Refer to these enum values for Policy / Payload status:

| Code | Status Name    |
|------|----------------|
| 0    | Unknown        |
| 1    | NotApplicable  |
| 2    | Compliant      |
| 3    | Remediated     |
| 4    | NonCompliant   |
| 5    | Error          |
| 6    | Conflict       |



### Application Enforcement Status Legend

The following legend augments application status outputs:

| EnforcementStatus | Meaning  |
|-------------------|----------|
| 1                 | Installed |
| 2                 | Failed |
| 3                 | NotInstalled |



### Device Details

Capture the device details for the provided `<DeviceId>` and summarize key fields (DeviceId, AccountId, PrimaryUser/EnrolledByUser, OSVersion, LastContact, SerialNumber, DeviceName, AzureAdDeviceId). This is the ONLY query you run for the device_details scenario. 

```kusto
let DeviceID = '<DeviceId>';
let base_query = (cluster: string, source: string) {
    cluster(cluster).database("qrybkradxglobaldb").Device_Snapshot()
        | where DeviceId == DeviceID
};
union
   base_query('qrybkradxeu01pe.northeurope.kusto.windows.net', 'europe'),  
   base_query('qrybkradxus01pe.westus2.kusto.windows.net', 'Non-EU')
```

### Enrollment Type Legend

| EnrollmentType | DeviceEnrollmentType | Meaning (Typical) | Notes |
|----------------|----------------------|-------------------|-------|
| 0 | 0 | Unknown / Default | Placeholder or not yet classified |
| 1 | 1 | MDM (User) | Standard user-driven MDM enrollment (Android/iOS) |
| 3 | 3 | MDM (macOS) | macOS direct MDM (low volume in sample) |
| 4 | 5 | Windows AAD MDM | Windows user-based (mapped variant) |
| 10 | 9 | Windows Autopilot / AAD Join | Includes provisioning / pre-provisioning scenarios |
| 19 | 3 | macOS (Alt Path) | macOS with alternate enrollment code path |
| 21 | 16 | Android Enterprise (Work Profile / Fully Managed) | AE deployment types (work profile / fully managed) |
| 26 | 20 | iOS/iPadOS Automated Device Enrollment (ADE) | Formerly DEP / supervised |


### User ID Lookup

Extract the userId(s) associated with the device (may return primary plus all-zero GUID). Use the central Intune telemetry table. If multiple values are returned, prefer the non-all-zero GUID as the primary user association.

```kusto
cluster("intune.kusto.windows.net").database("intune").IntuneEvent
| where DeviceId == "<DeviceId>"
| project UserId
```

### Tenant Information

Fetch the tenant info using the AccountId obtained in the "Device Details" scenario. Summarize the output, including ContextId, flighting tags, Tenant name and ScaleUnit.

```kusto
cluster("intune.kusto.windows.net").database("intune").WindowsAutopilot_GetTenantInformationFromEitherAccountIdContextIdOrName("<Fetch the accountId from Device Details and replace here>")
```

### Device Compliance Status (Last 10 Days)

Check the device compliance status and state changes for the device over the last 10 days and show the output as a table.

```kusto
cluster("intune.kusto.windows.net").database("intune").DeviceComplianceStatusChangesByDeviceId('<DeviceId>', ago(10d), now(), 1000)
```

### Policy / Setting Status and Assignments

Using the ContextId from Device Details, run the following queries and show the output (tables):

Policy setting status per device:


```kusto
// PolicySettingsStatus
GetAllPolicySettingsStatusForTenant(@'<ContextId from Step 2>')
| where DeviceId == "<DeviceId>"
```

// Overall policy status per device:


```kusto
GetAllPolicyStatusForTenant('<ContextId from Step 2>')
| where DeviceId == "<DeviceId>"
```

After checking the above 2 Kusto queries, check the below Kusto query to give more information about the PolicyId.

```kusto
IntuneEvent
| where DeviceId == "<DeviceId>"
| where * contains "<PolicyId or PayloadId>"
```

// Policy Assignments for Tenant (Settings Catalog, ASR, Device Configuration Policies) to Track Policy Deployment
GetAllPolicyAssignmentsForTenant('<TenantId>')

-------------------------------


### Effective Group Memberships and Troubleshooting

**Effective Group Troubleshooting Table**

| Step | Action | Query/Details |
|------|--------|---------------|
| 1    | Find Effective Group Id (EGID) for the device | See query below; use `<DeviceId>` and `<AccountId from Step 1>` |
| 2    | List groups within the Effective Group | Use `<EffectiveGroupId>` from Step 1 |
| 3    | Identify policies assigned to the group | Use `<PayloadId>`, `<AccountId from Step 1>`, and `<GroupId>` |
| 4    | Review policy assignments for the tenant | Use `<TenantId>` and `<PolicyId or PayloadId>` |

**Queries:**

**Step 1: Find the Effective Group Id (EGID) containing the device**
```kusto
union 
	cluster("qrybkradxus01pe.westus2.kusto.windows.net").database("qrybkradxglobaldb").EffectiveGroupMembershipV2_Snapshot(),
	cluster("qrybkradxeu01pe.northeurope.kusto.windows.net").database("qrybkradxglobaldb").EffectiveGroupMembershipV2_Snapshot()
| where AccountId == "<AccountId from Device Details>"
| where TargetId == "<DeviceId>" // or replace with a UserId to inspect user-scoped targeting
```

**Step 2: Groups within a specific Effective Group (EU primary, US fallback)**

```kusto
union
    cluster('qrybkradxeu01pe.northeurope.kusto.windows.net').database('qrybkradxglobaldb').EffectiveGroup_Snapshot()
    cluster('qrybkradxus01pe.westus2.kusto.windows.net').database('qrybkradxglobaldb').EffectiveGroup_Snapshot()
| where EffectiveGroupId == "<EffectiveGroupId>"
| project GroupsAsString
```

**Step 3: Policies assigned to a group (EU first, fallback to US)**
```kusto
union
    cluster('qrybkradxeu01pe.northeurope.kusto.windows.net').database('qrybkradxglobaldb').Deployment_Snapshot()
    cluster('qrybkradxus01pe.westus2.kusto.windows.net').database('qrybkradxglobaldb').Deployment_Snapshot()
| where PayloadId == "<PayloadId>"
| where AccountId == "<AccountId from Device Details>"
| where GroupId in ("<GroupId>")
| distinct GroupId
```

**Step 4: Policy assignments for the tenant**
```kusto
GetAllPolicyAssignmentsForTenant('<TenantId>')
| where PolicyId == "<PolicyId or PayloadId>"
```

Placeholders:
- `<DeviceId>` = Provided DeviceId for investigation
- `<AccountId from Step 1>` = AccountId retrieved from Device Details
- `<ContextId from Step 2>` = ContextId returned from Detailed Tenant Information
- `<EffectiveGroupId>` = Effective group identifier discovered above
- `<PayloadId>` = Policy / payload identifier of interest
- `<GroupId>` = Azure AD / Intune group Id
- `<TenantId>` = Tenant Id (often same as AccountId but confirm)
- `<PolicyId or PayloadId>` = Specific policy/payload to filter

**Multi-Value Column Expansion Pattern (Readable Tables)**

Kusto pattern to expand `GroupsAsString`:

```kusto
// Raw (primary) table — use as-is for the first output table
let RawEG = EffectiveGroup_Snapshot()
	| where EffectiveGroupId == '<EffectiveGroupId>'
	| project EffectiveGroupId, GroupsAsString;
RawEG;

// Expanded (secondary) table — one row per GroupId
RawEG
| extend GroupArray = split(GroupsAsString, ',')
| mv-expand GroupArray
| project EffectiveGroupId, GroupId = trim(' ', GroupArray)
```

If multiple multi-value columns exist, repeat the expansion for each (producing additional labeled tables) rather than overloading a single wide table.


### MAM Policy 

// To check all the MAM Policy deployed to the device.
```Kusto
cluster("intune.kusto.windows.net").database("intune").
GetAllMAMPolicyStatusForTenant("ContextId")
| where DeviceId == "DeviceId"
```

### Applications

//Get all the application status for the tenant
```kusto
GetAllAppStatusForTenant('ce6f9430-1d64-4a97-a32d-e92a05a11971')
| where DeviceId == "DeviceId"
```

// Get all the application details for the tenant
```kusto
GetAllApplicationsForTenant(@'b749cbc5-432b-40f6-a389-ed007659d2d0')
```

// Application install attemps by device Id
```kusto
ApplicationInstallAttemptsByDeviceId("790ed67d-8983-4603-90c0-725452a273ee", datetime(2025-08-05 05:42:00),datetime(2025-08-13 05:42:00),1000)
```


// More application deployment details with message.
```Kusto
DeviceManagementProvider
|where env_time >= ago(30d)
|where ActivityId == "deviceId" 
```


### Third Party Integration(JAMF)

cluster("https://qrybkradxus01pe.westus2.kusto.windows.net").database("qrybkradxglobaldb").MTPartnerTenantService_Snapshot
|where AccountId == "<Intune Account Id>"

### Identify conflicting DCv1 and DCv2 policies

Use this query to identify conflicting DCv1 and DCv2 policies. Replace the placeholder with the deviceId the user is interested in.

```Kusto
// Purpose: To find conflicting DCv1 and DCv2 policies for a given device
let DeviceID = '<deviceId>';
let base_query = (cluster: string, source: string) {
    let Device_Snapshot = cluster(cluster).database('qrybkradxglobaldb').Device_Snapshot;
    let AccountID = toscalar(Device_Snapshot | where DeviceId == DeviceID | project AccountId);
    let ASU = toscalar(Device_Snapshot | where DeviceId == DeviceID | project ScaleUnitName);
    let PolicySettingMap = materialize(cluster(cluster).database('qrybkradxglobaldb').PolicySettingMapV3_Snapshot | where AccountId == AccountID);
    let SettingsLevelData = 
        cluster(cluster).database('qrybkradxglobaldb').IntentSettingStatusPerDevicePerUserV2_Snapshot
        | where ScaleUnitName == ASU and AccountId == AccountID and DeviceId == DeviceID
        | extend Source="IntentSettingStatus", LastModifiedTimeUtc=IntentSettingStatusPerDevicePerUserLastUpdateTimeUTC
        | union (
            cluster(cluster).database('qrybkradxglobaldb').SettingStatusPerDevicePerUserV1_Snapshot
            | where ScaleUnitName == ASU and AccountId == AccountID and DeviceId == DeviceID
            | join kind=leftouter PolicySettingMap on $left.SettingId == $right.SettingId
            | extend Source="SettingStatusV1", LastModifiedTimeUtc=SspdpuLastModifiedTimeUtc)
        | union (
            cluster(cluster).database('qrybkradxglobaldb').SettingStatusPerDevicePerUserV3_Snapshot
            | where ScaleUnitName == ASU and AccountId == AccountID and DeviceId == DeviceID
            | extend Source="SettingStatusV3", LastModifiedTimeUtc=SspdpuLastModifiedTimeUtc)
        | union (
            cluster(cluster).database('qrybkradxglobaldb').AdmxPolicySettingStatusPerDevicePerUserV1_Snapshot
            | where ScaleUnitName == ASU and AccountId == AccountID and DeviceId == DeviceID
            | extend Source="AdmxSettingStatus", LastModifiedTimeUtc=LastModifiedTimeUtc)
        | project DeviceId, UserId, PolicyId, SettingName, SettingInstancePath,
                 Status = case(SettingStatus == 0, "Unknown", SettingStatus == 1, "NotApplicable", SettingStatus == 2, "Compliant", SettingStatus == 3, "Remediated", SettingStatus == 4, "NotCompliant", SettingStatus == 5, "Error", SettingStatus == 6, "Conflict", ""),
                 ErrorTypeName = case(ErrorType == 0, "None", ErrorType == 1, "DeviceCheckinDiscovery", ErrorType == 2, "DeviceCheckinRemediation", ErrorType == 3, "DeviceCheckinCompliance", ErrorType == 4, "DeviceCheckinProcessing", ErrorType == 5, "DeviceCheckinConflict", ErrorType == 6, "DeviceCheckinConflictResolution", ErrorType == 7, "PolicyReportProcessing", ErrorType == 32, "GroupPolicy", ErrorType == 64, "DFCI", "Other"),
                 ErrorCode, LastModifiedTimeUtc, PolicyVersion, SettingId, SettingInstanceId, Source
        | distinct DeviceId, UserId, PolicyId, SettingName, SettingInstancePath, Status, ErrorTypeName, ErrorCode, LastModifiedTimeUtc, PolicyVersion, SettingId, SettingInstanceId, Source;
    let PolicyMetadata = 
        cluster(cluster).database('qrybkradxglobaldb').CombinedPolicyMetadataWithScopeTags_Snapshot
        | where ScaleUnitName == ASU and AccountId == AccountID
        | extend Source="PolicyMetadata"
        | union (
            cluster(cluster).database('qrybkradxglobaldb').DeviceIntentMetadataV2_Snapshot
            | where ScaleUnitName == ASU and AccountId == AccountID
            | extend Source="IntentMetadata")
        | union (
            cluster(cluster).database('qrybkradxglobaldb').PolicyMetadataV1_Snapshot
            | where ScaleUnitName == ASU and AccountId == AccountID
            | extend Source="PolicyMetadataV1")
        | project PolicyId, PolicyName, PolicyBaseTypeName;
    let PayloadTypeMap = cluster(cluster).database('qrybkradxglobaldb').DeploymentStatus_Snapshot
        | where AccountId == AccountID
        | distinct PayloadId, PayloadType;    SettingsLevelData
    | join kind=leftouter PayloadTypeMap on $left.PolicyId == $right.PayloadId
    | join kind=leftouter PolicyMetadata on PolicyId
    | extend PayloadTypeDescription = case(PayloadType == 1, "DCv1", PayloadType == 29, "DCv2", strcat("PayloadType_", tostring(PayloadType))), HasSettingDetails = true
    | where PayloadType in (1, 29) and Status == "Conflict"
    | as ConflictData    | join kind=leftouter (
        ConflictData 
        | where PayloadTypeDescription == "DCv1"
        | extend 
            HasKeyPattern = SettingInstancePath contains "Key='",
            ExtractedPath = case(
                SettingInstancePath contains "Key='",
                tostring(split(SettingInstancePath, "Key='")[1]),
                SettingInstancePath
            )
        | extend 
            CleanPath = case(
                HasKeyPattern,
                tostring(split(ExtractedPath, "'")[0]),
                ExtractedPath
            )
        | extend DCv1_SettingName = tostring(split(CleanPath, "/")[-1])
        | project DeviceId, UserId, DCv1_PolicyId = PolicyId, DCv1_PolicyName = PolicyName, DCv1_SettingName, DCv1_SettingInstancePath = SettingInstancePath
    ) on DeviceId, UserId, $left.SettingName == $right.DCv1_SettingName
    | project AccountID, DeviceId, UserId, PolicyId, PolicyName, PolicyBaseTypeName, PayloadType, PayloadTypeDescription, SettingName,
             ConflictingDCv1_PolicyId = case(PayloadTypeDescription == "DCv2", DCv1_PolicyId, ""),
             ConflictingDCv1_PolicyName = case(PayloadTypeDescription == "DCv2", DCv1_PolicyName, ""),
             ConflictingDCv1_SettingPath = case(PayloadTypeDescription == "DCv2", DCv1_SettingInstancePath, ""),
             SettingInstancePath, Status, ErrorTypeName, ErrorCode, LastModifiedTimeUtc, PolicyVersion, SettingId, SettingInstanceId, Source, HasSettingDetails
    | where ConflictingDCv1_PolicyId != ""
    | distinct *
    | order by PolicyId, HasSettingDetails desc, SettingName
};
union
   base_query('qrybkradxeu01pe.northeurope.kusto.windows.net', 'europe'),
   base_query('qrybkradxus01pe.westus2.kusto.windows.net', 'Non-EU')
```

### Autopilot Summary Investigation Workflow

**When user asks for "Autopilot summary for device <DeviceId>":**

Execute the following queries in sequence to provide a comprehensive Autopilot summary:

**Step 1: Get Device Account Information**
```kusto
// Purpose: Extract AccountId and basic device info to establish tenant context
cluster("https://intune.kusto.windows.net").database("Intune").IntuneEvent
| where DeviceId == "<DeviceId>"
| where env_time >= ago(15d)
| summarize arg_max(env_time, AccountId, ContextId) by DeviceId
| project DeviceId, AccountId, ContextId, LatestActivity = env_time
```

**Step 2: Get Tenant Information**
```kusto
// Purpose: Get ContextId and tenant details using AccountId from Step 1
cluster("https://intune.kusto.windows.net").database("intune").WindowsAutopilot_GetTenantInformationFromEitherAccountIdContextIdOrName("<AccountId from Step 1>")
```

**Step 3: Get Autopilot Device Details**
```kusto
// Purpose: Get ZTD registration, profile assignment, and device details
// Try US cluster first
cluster("https://qrybkradxus01pe.westus2.kusto.windows.net").database("qrybkradxglobaldb").ZTDDevice_Snapshot()
| where DeviceId == "<DeviceId>"
| project ScaleUnitName, AccountId, ZTDRegistrationId, IntuneProfileIdentifier, IntuneProfileAssignedTime, IntuneProfileAssignmentStatus, DeviceId, ZTDConfigProfileIdentifier, ZTDCreatedTime, ZTDUpdatedTime, ZTDProfileSetTime, ZTDOemManufacturer, ZTDModelName, ZTDProfileAssignErrorCodeString, ZTDDeviceSyncErrorCodeString, IsDeleted, AADObjectId

// Fallback to EU cluster if US fails
cluster("https://qrybkradxeu01pe.northeurope.kusto.windows.net").database("qrybkradxglobaldb").ZTDDevice_Snapshot()
| where DeviceId == "<DeviceId>"
| project ScaleUnitName, AccountId, ZTDRegistrationId, IntuneProfileIdentifier, IntuneProfileAssignedTime, IntuneProfileAssignmentStatus, DeviceId, ZTDConfigProfileIdentifier, ZTDCreatedTime, ZTDUpdatedTime, ZTDProfileSetTime, ZTDOemManufacturer, ZTDModelName, ZTDProfileAssignErrorCodeString, ZTDDeviceSyncErrorCodeString, IsDeleted, AADObjectId
```

**Step 4: Get ESP Policy Information**
```kusto
// Purpose: Get ESP policy details and device provisioning progress
cluster("https://intune.kusto.windows.net").database("intune").IntuneEvent
| where ComponentName == "StatelessEnrollmentService"
| where EventUniqueName == "DeviceProvisioningProgressEvent"
| where DeviceId == "<DeviceId>"
| where env_time >= ago(15d)
| project env_time, DeviceName=Col1, ZtdProfileName=Col2, SerialNumber=Col3, ZtdRegisteredTime=Col4, ESPPolicyName=Col5, ESPPolicyId=Col6, DeviceId, UserId
```

**Step 5: Get ESP Configuration Policies**
```kusto
// Purpose: Get detailed ESP policy assignments and configuration
let DID = '<DeviceId>';
let UID = '<UserId from Step 4>';
union cluster('qrybkradxus01pe.westus2.kusto.windows.net').database('qrybkradxglobaldb').EnrollmentConfigurationPoliciesByDevice_Snapshot(), cluster('qrybkradxeu01pe.northeurope.kusto.windows.net').database('qrybkradxglobaldb').EnrollmentConfigurationPoliciesByDevice_Snapshot()
| where PolicyType == "27"
| where DeviceId == iff(DID=="","E*mptyAccountValue",DID) or UserId == iff(UID=="","E*mptyAccountValue",UID)
| extend Target = case(
Target == 0,"Include",
Target == 1,"Exclude",
"Undefined"
)
| project ScaleUnitName, AccountId, DeviceId, PolicyId, Target, PolicyType, ProfileName, UserId, UserPrincipalName, State, Priority, FilterIds, LastAppliedTime
```

**Step 6: Check ESP Failures**
```kusto
// Purpose: Check for any ESP failures for the device
cluster("https://intune.kusto.windows.net").database("intune").GetEspFailuresForTenant("<ContextId from Step 2>", "<AccountId from Step 1>", ago(15d), now())
| where DeviceId == "<DeviceId>"
```

**Step 7: Get ESP Applications**
```kusto
// Purpose: Get applications deployed during ESP session
cluster("https://intune.kusto.windows.net").database("intune").IntuneEvent
| where DeviceId == "<DeviceId>"
| where env_time >= ago(15d)
| where ComponentName == "DeviceCheckinESP"
| where EventUniqueName == "ESPReport"
| project env_time, Message, Col1, Col2, Col3
| order by env_time asc
```

**Step 8: Get ESP Timeline**
```kusto
// Purpose: Get ESP session timeline and status changes
cluster("https://intune.kusto.windows.net").database("intune").IntuneEvent
| where DeviceId == "<DeviceId>"
| where env_time >= ago(15d)
| where ComponentName == "DeviceCheckinESP"
| project env_time, EventUniqueName, Message, Col1, Col2, Col3
| order by env_time asc
```

**Step 9: Get Effective Groups**
```kusto
// Purpose: Get effective group memberships for policy targeting
// Use US cluster (primary working method)
EffectiveGroupMembershipV2_Snapshot()
| where TargetId == "<DeviceId>"
| project AccountId, TargetId, EffectiveGroupId, MDMAuthority, TargetType, DeviceSource, EffectiveGroupCreatedDateTime, EffectiveGroupChangeTime, CreatedDateTime, LastModifiedDateTime
```

**Output Format for Autopilot Summary:**

Present results in this structured format:

1. **Device Account Information Table**
2. **Tenant Information Table**
3. **Autopilot Device Details Table**
4. **ESP Policy Information Table**
5. **ESP Configuration Policies Table** (filtered to current device)
6. **ESP Failures Table** (or "No failures found")
7. **ESP Applications Table**
8. **ESP Timeline Table**
9. **Effective Groups Table** (if successfully retrieved)

**Summary Section should include:**
- Autopilot Profile Assignment Status
- ESP Policy Name and ID
- Device Registration Timeline
- ESP Session Duration and Status
- Application Deployment Status
- User Information (ID and UPN)
- Serial Number and Device Details
- Any Failures or Issues Detected

**Key Information to Extract:**
- `IsEspContinueAnywayEnabled` (from ESP configuration)
- `DeviceName` (from provisioning progress)
- `ZtdProfileName` (Autopilot profile name)
- `ZtdDeviceSerialNumber` (device serial)
- `ZtdDeviceRegisteredTime` (registration timestamp)
- `ESPPolicyName` and `ESPPolicyId`
- ESP blocking apps status
- ESP timeline (start/end times)

### Multi-Value Column Expansion Pattern (Readable Tables)

Kusto pattern to expand `GroupsAsString`:

```kusto
// Raw (primary) table — use as-is for the first output table
let RawEG = EffectiveGroup_Snapshot()
	| where EffectiveGroupId == '<EffectiveGroupId>'
	| project EffectiveGroupId, GroupsAsString;
RawEG;

// Expanded (secondary) table — one row per GroupId
RawEG
| extend GroupArray = split(GroupsAsString, ',')
| mv-expand GroupArray
| project EffectiveGroupId, GroupId = trim(' ', GroupArray)
```

If multiple multi-value columns exist, repeat the expansion for each (producing additional labeled tables) rather than overloading a single wide table.

### Advanced Scenario: Device Timeline

Aggregate a chronological timeline of key device events between `<StartTime>` and `<EndTime>` for `<DeviceId>`. This includes:
- Compliance state changes
- Policy / setting status touches (conflicts/errors) in window
- Application install attempts / status changes
- Device management provider (check‑in / activity) events
- Device snapshot baseline (for AccountId/Context/ScaleUnit resolution)
- Effective group membership discovery and related group definition / deployments
- Relevant raw IntuneEvent telemetry slice for correlation
- (Optional) Policy assignment records if a PolicyId/PayloadId emerges during analysis

**RATE LIMITING PROTECTION**: This scenario implements pagination and row limits to prevent Kusto rate limiting:
- Each query is limited to 500 rows maximum (reduced from 5000)
- Time range is automatically chunked into 24-hour segments if > 7 days
- Raw IntuneEvent queries are heavily filtered and limited to 200 rows
- Union queries apply filters early to reduce cross-region data transfer

Return each dataset as a separate table (in this order) without projecting or renaming columns; preserve the full native schema from each source query. After collecting them, provide a summary highlighting:
1. First and last event timestamps present in each dataset (use their native time columns)
2. Approximate counts per dataset (note if results were truncated due to limits)
3. Any error / conflict statuses encountered as-is
4. Notable gaps > 12h between consecutive native timestamps (if detectable)
5. If data was truncated, suggest narrowing the time range for complete results

Use ONLY the queries below. Substitute placeholders before execution:

```kusto
let DeviceID = '<DeviceId>';
let base_query = (cluster: string, source: string) {
    cluster(cluster).database("qrybkradxglobaldb").Device_Snapshot()
        | where DeviceId == DeviceID
};
union
   base_query('qrybkradxeu01pe.northeurope.kusto.windows.net', 'europe'),  
   base_query('qrybkradxus01pe.westus2.kusto.windows.net', 'Non-EU')
```

```kusto
// Compliance changes timeline (limited to 500 rows, most recent first)
cluster("intune.kusto.windows.net").database("intune").DeviceComplianceStatusChangesByDeviceId('<DeviceId>', datetime(<StartTime>), datetime(<EndTime>), 500)
| order by env_time desc
| limit 500
```

```kusto
// Device snapshot baseline to resolve AccountId / ContextId / ScaleUnitName if needed later
let DeviceID = '<DeviceId>';
let base_query = (cluster: string, source: string) {
    cluster(cluster).database("qrybkradxglobaldb").Device_Snapshot()
        | where DeviceId == DeviceID
};
union
   base_query('qrybkradxeu01pe.northeurope.kusto.windows.net', 'europe'),  
   base_query('qrybkradxus01pe.westus2.kusto.windows.net', 'Non-EU')
```

```kusto
// Effective Group Membership (filtered early, limited)
let deviceId = '<DeviceId>';
union 
    (cluster("qrybkradxus01pe.westus2.kusto.windows.net").database("qrybkradxglobaldb").EffectiveGroupMembershipV2_Snapshot()
     | where TargetId == deviceId
     | limit 100),
    (cluster("qrybkradxeu01pe.northeurope.kusto.windows.net").database("qrybkradxglobaldb").EffectiveGroupMembershipV2_Snapshot()
     | where TargetId == deviceId
     | limit 100)
| limit 200
```

```kusto
// Effective Group definition (union both regions, limited) — run only if EffectiveGroupId(s) discovered
let groupIds = dynamic([<EffectiveGroupIdList>]);
union 
    (cluster('qrybkradxeu01pe.northeurope.kusto.windows.net').database('qrybkradxglobaldb').EffectiveGroup_Snapshot()
     | where EffectiveGroupId in (groupIds)
     | limit 50),
    (cluster('qrybkradxus01pe.westus2.kusto.windows.net').database('qrybkradxglobaldb').EffectiveGroup_Snapshot()
     | where EffectiveGroupId in (groupIds)
     | limit 50)
| limit 100
```

```kusto
// Deployment snapshot (union both regions, limited) for discovered PayloadId/GroupIds
let groupIds = dynamic([<GroupIdList>]);
union 
    (cluster('qrybkradxeu01pe.northeurope.kusto.windows.net').database('qrybkradxglobaldb').Deployment_Snapshot()
     | where GroupId in (groupIds)
     | limit 100),
    (cluster('qrybkradxus01pe.westus2.kusto.windows.net').database('qrybkradxglobaldb').Deployment_Snapshot()
     | where GroupId in (groupIds)
     | limit 100)
| limit 200
```

```kusto
// Application install attempts within window (limited to 500 rows, most recent first)
cluster("intune.kusto.windows.net").database("intune").ApplicationInstallAttemptsByDeviceId('<DeviceId>', datetime(<StartTime>), datetime(<EndTime>), 500)
| order by env_time desc
| limit 500
```

```kusto
// Device check-in activity (high level, limited to 500 rows)
cluster("intune.kusto.windows.net").database("intune").HighLevelCheckin(deviceIdentifier='<DeviceId>', startTime='<StartTime>', endTime='<EndTime>')
| order by env_time desc
| limit 500
```

```kusto
// Policy assignments if a PolicyId/PayloadId was identified
cluster("intune.kusto.windows.net").database("intune").GetAllPolicyAssignmentsForTenant('<TenantId>')
| where PolicyId in (<PolicyIdList>)
| limit 100
```

**TIME RANGE OPTIMIZATION**:
- For time ranges > 7 days: Automatically suggest breaking into 24-hour or weekly chunks
- For time ranges > 30 days: Strongly recommend focusing on specific time periods or event types
- Always sort by timestamp descending to get most recent events first
- If user requests "last 30 days" but data is truncated, suggest "last 7 days" for complete results

**PAGINATION STRATEGY FOR LARGE TIME RANGES**:
If original query returns exactly the row limit (indicating truncation), suggest:
1. "Results were limited to {N} rows. For complete timeline, try smaller time ranges:"
2. "- Last 7 days: `<StartTime>` to `<EndTime-7days>`"
3. "- Specific date range: `YYYY-MM-DD 00:00:00` to `YYYY-MM-DD 23:59:59`"
4. "- Focus on errors only: Use policy/compliance queries with error filtering"

Placeholders for this scenario:
- `<DeviceId>`: Target device GUID
- `<StartTime>`: Inclusive UTC start timestamp (e.g. 2025-09-01 00:00:00)
- `<EndTime>`: Exclusive / inclusive end timestamp as needed (use consistent interpretation)
- `<EffectiveGroupIdList>`: Comma-separated list of EffectiveGroupId values from membership query (quote each if needed)
- `<GroupIdList>`: Comma-separated list of GroupId values derived from Effective Group definitions (quote each if needed)
- `<PolicyIdList>`: Comma-separated list of PolicyId/PayloadId values discovered (quote each if needed)
- `<TenantId>`: Tenant identifier (from device snapshot AccountId if required)

Execution Notes:
- Always run individual source queries first (separate tables). Do NOT only return a merged union unless explicitly requested.
- If any dataset yields zero rows, still emit the table per global Output Rules.
- **RATE LIMITING PROTECTION**: All queries are limited to prevent Kusto throttling:
  - Compliance/Apps: 500 rows max (reduced from 5000)
  - Policy/Setting: 500 rows max with early filtering
  - Group data: 200 rows max
  - IntuneEvent: 200 rows max with heavy filtering (errors/warnings only)
  - All other queries: 100-500 row limits
- **TIME RANGE GUIDANCE**: For periods > 7 days, recommend splitting into smaller chunks (e.g., daily) to get complete data
- If results are truncated due to limits, inform user and suggest narrowing time range or focusing on specific event types
- Truncate to 50 for display with ellipsis row if needed per Output Rules, but mention actual row count retrieved
